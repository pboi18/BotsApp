/**
 * @module QRCode
 * @package @nuintun/qrcode
 * @license MIT
 * @version 3.3.0
 * @author nuintun <nuintun@qq.com>
 * @description A pure JavaScript QRCode encode and decode library.
 * @see https://github.com/nuintun/qrcode#readme
 */

'use strict';

var ByteArrayOutputStream = require('../io/ByteArrayOutputStream.cjs');
var Base64EncodeOutputStream = require('../io/Base64EncodeOutputStream.cjs');

/**
 * @module GIF Image (B/W)
 * @author nuintun
 * @author Kazuhiko Arase
 */
function encodeToBase64(data) {
  var output = new ByteArrayOutputStream.ByteArrayOutputStream();
  var stream = new Base64EncodeOutputStream.Base64EncodeOutputStream(output);
  stream.writeBytes(data);
  stream.close();
  output.close();
  return output.toByteArray();
}
var LZWTable = /*#__PURE__*/ (function () {
  function LZWTable() {
    this.size = 0;
    this.map = {};
  }
  LZWTable.prototype.add = function (key) {
    if (!this.contains(key)) {
      this.map[key] = this.size++;
    }
  };
  LZWTable.prototype.getSize = function () {
    return this.size;
  };
  LZWTable.prototype.indexOf = function (key) {
    return this.map[key];
  };
  LZWTable.prototype.contains = function (key) {
    return this.map[key] >= 0;
  };
  return LZWTable;
})();
var BitOutputStream = /*#__PURE__*/ (function () {
  function BitOutputStream(output) {
    this.output = output;
    this.bitLength = 0;
    this.bitBuffer = 0;
  }
  BitOutputStream.prototype.write = function (data, length) {
    if (data >>> length !== 0) {
      throw new Error('length overflow');
    }
    var output = this.output;
    while (this.bitLength + length >= 8) {
      output.writeByte(0xff & ((data << this.bitLength) | this.bitBuffer));
      length -= 8 - this.bitLength;
      data >>>= 8 - this.bitLength;
      this.bitBuffer = 0;
      this.bitLength = 0;
    }
    this.bitBuffer = (data << this.bitLength) | this.bitBuffer;
    this.bitLength = this.bitLength + length;
  };
  BitOutputStream.prototype.flush = function () {
    var output = this.output;
    if (this.bitLength > 0) {
      output.writeByte(this.bitBuffer);
    }
    output.flush();
  };
  BitOutputStream.prototype.close = function () {
    this.flush();
    this.output.close();
  };
  return BitOutputStream;
})();
var GIFImage = /*#__PURE__*/ (function () {
  function GIFImage(width, height) {
    this.data = [];
    this.width = width;
    this.height = height;
    var size = width * height;
    for (var i = 0; i < size; i++) {
      this.data[i] = 0;
    }
  }
  GIFImage.prototype.getLZWRaster = function (lzwMinCodeSize) {
    // Setup LZWTable
    var table = new LZWTable();
    var fromCharCode = String.fromCharCode;
    var clearCode = 1 << lzwMinCodeSize;
    var endCode = (1 << lzwMinCodeSize) + 1;
    for (var i = 0; i < clearCode; i++) {
      table.add(fromCharCode(i));
    }
    table.add(fromCharCode(clearCode));
    table.add(fromCharCode(endCode));
    var bitLength = lzwMinCodeSize + 1;
    var byteOutput = new ByteArrayOutputStream.ByteArrayOutputStream();
    var bitOutput = new BitOutputStream(byteOutput);
    try {
      var data = this.data;
      var length_1 = data.length;
      var fromCharCode_1 = String.fromCharCode;
      // Clear code
      bitOutput.write(clearCode, bitLength);
      var dataIndex = 0;
      var words = fromCharCode_1(data[dataIndex++]);
      while (dataIndex < length_1) {
        var char = fromCharCode_1(data[dataIndex++]);
        if (table.contains(words + char)) {
          words += char;
        } else {
          bitOutput.write(table.indexOf(words), bitLength);
          if (table.getSize() < 0xfff) {
            if (table.getSize() === 1 << bitLength) {
              bitLength++;
            }
            table.add(words + char);
          }
          words = char;
        }
      }
      bitOutput.write(table.indexOf(words), bitLength);
      // End code
      bitOutput.write(endCode, bitLength);
    } finally {
      bitOutput.close();
    }
    return byteOutput.toByteArray();
  };
  GIFImage.prototype.setPixel = function (x, y, pixel) {
    var _a = this,
      width = _a.width,
      height = _a.height;
    if (x < 0 || width <= x) throw new Error('illegal x axis: '.concat(x));
    if (y < 0 || height <= y) throw new Error('illegal y axis: '.concat(y));
    this.data[y * width + x] = pixel;
  };
  GIFImage.prototype.getPixel = function (x, y) {
    var _a = this,
      width = _a.width,
      height = _a.height;
    if (x < 0 || width <= x) throw new Error('illegal x axis: '.concat(x));
    if (y < 0 || height <= y) throw new Error('illegal y axis: '.concat(y));
    return this.data[y * width + x];
  };
  GIFImage.prototype.write = function (output) {
    var _a = this,
      width = _a.width,
      height = _a.height;
    // GIF Signature
    output.writeByte(0x47); // G
    output.writeByte(0x49); // I
    output.writeByte(0x46); // F
    output.writeByte(0x38); // 8
    output.writeByte(0x37); // 7
    output.writeByte(0x61); // a
    // Screen Descriptor
    output.writeInt16(width);
    output.writeInt16(height);
    output.writeByte(0x80); // 2bit
    output.writeByte(0);
    output.writeByte(0);
    // Global Color Map
    // Black
    output.writeByte(0x00);
    output.writeByte(0x00);
    output.writeByte(0x00);
    // White
    output.writeByte(0xff);
    output.writeByte(0xff);
    output.writeByte(0xff);
    // Image Descriptor
    output.writeByte(0x2c); // ,
    output.writeInt16(0);
    output.writeInt16(0);
    output.writeInt16(width);
    output.writeInt16(height);
    output.writeByte(0);
    // Local Color Map
    // Raster Data
    var lzwMinCodeSize = 2;
    var raster = this.getLZWRaster(lzwMinCodeSize);
    var raLength = raster.length;
    output.writeByte(lzwMinCodeSize);
    var offset = 0;
    while (raLength - offset > 255) {
      output.writeByte(255);
      output.writeBytes(raster, offset, 255);
      offset += 255;
    }
    var length = raLength - offset;
    output.writeByte(length);
    output.writeBytes(raster, offset, length);
    output.writeByte(0x00);
    // GIF Terminator
    output.writeByte(0x3b); // ;
  };
  GIFImage.prototype.toDataURL = function () {
    var output = new ByteArrayOutputStream.ByteArrayOutputStream();
    this.write(output);
    var bytes = encodeToBase64(output.toByteArray());
    output.close();
    var length = bytes.length;
    var fromCharCode = String.fromCharCode;
    var url = 'data:image/gif;base64,';
    for (var i = 0; i < length; i++) {
      url += fromCharCode(bytes[i]);
    }
    return url;
  };
  return GIFImage;
})();

exports.GIFImage = GIFImage;

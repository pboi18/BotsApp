/**
 * @module QRCode
 * @package @nuintun/qrcode
 * @license MIT
 * @version 3.3.0
 * @author nuintun <nuintun@qq.com>
 * @description A pure JavaScript QRCode encode and decode library.
 * @see https://github.com/nuintun/qrcode#readme
 */

'use strict';

var QRByte = require('./QRByte.cjs');
var QRData = require('./QRData.cjs');
var QRUtil = require('./QRUtil.cjs');
var RSBlock = require('./RSBlock.cjs');
var Mode = require('../common/Mode.cjs');
var BitBuffer = require('./BitBuffer.cjs');
var Polynomial = require('./Polynomial.cjs');
var GIFImage = require('../../image/GIFImage.cjs');
var MaskPattern = require('../common/MaskPattern.cjs');
var ErrorCorrectionLevel = require('../common/ErrorCorrectionLevel.cjs');

/**
 * @module QRCode
 * @author nuintun
 * @author Kazuhiko Arase
 */
var PAD0 = 0xec;
var PAD1 = 0x11;
var toString = Object.prototype.toString;
/**
 * @function appendECI
 * @param {number} encoding
 * @param {BitBuffer} buffer
 * @see https://github.com/nayuki/QR-Code-generator/blob/master/typescript-javascript/qrcodegen.ts
 * @see https://github.com/zxing/zxing/blob/master/core/src/main/java/com/google/zxing/qrcode/encoder/Encoder.java
 */
function appendECI(encoding, buffer) {
  if (encoding < 0 || encoding >= 1000000) {
    throw new Error('byte mode encoding hint out of range');
  }
  buffer.put(Mode.Mode.ECI, 4);
  if (encoding < 1 << 7) {
    buffer.put(encoding, 8);
  } else if (encoding < 1 << 14) {
    buffer.put(2, 2);
    buffer.put(encoding, 14);
  } else {
    buffer.put(6, 3);
    buffer.put(encoding, 21);
  }
}
function prepareData(version, errorCorrectionLevel, encodingHint, chunks) {
  var buffer = new BitBuffer.BitBuffer();
  var rsBlocks = RSBlock.RSBlock.getRSBlocks(version, errorCorrectionLevel);
  for (var _i = 0, chunks_1 = chunks; _i < chunks_1.length; _i++) {
    var data = chunks_1[_i];
    var mode = data.mode;
    // Default set encoding UTF-8 when has encoding hint
    if (encodingHint && mode === Mode.Mode.Byte) {
      appendECI(data.encoding, buffer);
    }
    buffer.put(mode, 4);
    buffer.put(data.getLength(), data.getLengthInBits(version));
    data.writeTo(buffer);
  }
  // Calc max data count
  var maxDataCount = 0;
  for (var _a = 0, rsBlocks_1 = rsBlocks; _a < rsBlocks_1.length; _a++) {
    var rsBlock = rsBlocks_1[_a];
    maxDataCount += rsBlock.getDataCount();
  }
  maxDataCount *= 8;
  return [buffer, rsBlocks, maxDataCount];
}
function createBytes(buffer, rsBlocks) {
  var offset = 0;
  var maxDcCount = 0;
  var maxEcCount = 0;
  var dcData = [];
  var ecData = [];
  var rsLength = rsBlocks.length;
  var bufferData = buffer.getBuffer();
  for (var r = 0; r < rsLength; r++) {
    var rsBlock = rsBlocks[r];
    var dcCount = rsBlock.getDataCount();
    var ecCount = rsBlock.getTotalCount() - dcCount;
    maxDcCount = Math.max(maxDcCount, dcCount);
    maxEcCount = Math.max(maxEcCount, ecCount);
    dcData[r] = [];
    for (var i = 0; i < dcCount; i++) {
      dcData[r][i] = 0xff & bufferData[i + offset];
    }
    offset += dcCount;
    var rsPoly = QRUtil.getErrorCorrectionPolynomial(ecCount);
    var ecLength = rsPoly.getLength() - 1;
    var rawPoly = new Polynomial.Polynomial(dcData[r], ecLength);
    var modPoly = rawPoly.mod(rsPoly);
    var mpLength = modPoly.getLength();
    ecData[r] = [];
    for (var i = 0; i < ecLength; i++) {
      var modIndex = i + mpLength - ecLength;
      ecData[r][i] = modIndex >= 0 ? modPoly.getAt(modIndex) : 0;
    }
  }
  buffer = new BitBuffer.BitBuffer();
  for (var i = 0; i < maxDcCount; i++) {
    for (var r = 0; r < rsLength; r++) {
      if (i < dcData[r].length) {
        buffer.put(dcData[r][i], 8);
      }
    }
  }
  for (var i = 0; i < maxEcCount; i++) {
    for (var r = 0; r < rsLength; r++) {
      if (i < ecData[r].length) {
        buffer.put(ecData[r][i], 8);
      }
    }
  }
  return buffer;
}
function createData(buffer, rsBlocks, maxDataCount) {
  // End
  if (buffer.getLengthInBits() + 4 <= maxDataCount) {
    buffer.put(0, 4);
  }
  // Padding
  while (buffer.getLengthInBits() % 8 !== 0) {
    buffer.putBit(false);
  }
  // Padding
  while (true) {
    if (buffer.getLengthInBits() >= maxDataCount) {
      break;
    }
    buffer.put(PAD0, 8);
    if (buffer.getLengthInBits() >= maxDataCount) {
      break;
    }
    buffer.put(PAD1, 8);
  }
  return createBytes(buffer, rsBlocks);
}
var Encoder = /*#__PURE__*/ (function () {
  function Encoder(options) {
    if (options === void 0) {
      options = {};
    }
    this.matrixSize = 0;
    this.chunks = [];
    this.matrix = [];
    var _a = options.version,
      version = _a === void 0 ? 0 : _a,
      _b = options.encodingHint,
      encodingHint = _b === void 0 ? false : _b,
      _c = options.errorCorrectionLevel,
      errorCorrectionLevel = _c === void 0 ? ErrorCorrectionLevel.ErrorCorrectionLevel.L : _c;
    this.setVersion(version);
    this.setEncodingHint(encodingHint);
    this.setErrorCorrectionLevel(errorCorrectionLevel);
  }
  /**
   * @public
   * @method getMatrix
   * @returns {boolean[][]}
   */
  Encoder.prototype.getMatrix = function () {
    return this.matrix;
  };
  /**
   * @public
   * @method getMatrixSize
   * @returns {number}
   */
  Encoder.prototype.getMatrixSize = function () {
    return this.matrixSize;
  };
  /**
   * @public
   * @method getVersion
   * @returns {number}
   */
  Encoder.prototype.getVersion = function () {
    return this.version;
  };
  /**
   * @public
   * @method setVersion
   * @param {number} version
   * @returns {Encoder}
   */
  Encoder.prototype.setVersion = function (version) {
    this.version = Math.min(40, Math.max(0, version >> 0));
    this.auto = this.version === 0;
    return this;
  };
  /**
   * @public
   * @method getErrorCorrectionLevel
   * @returns {ErrorCorrectionLevel}
   */
  Encoder.prototype.getErrorCorrectionLevel = function () {
    return this.errorCorrectionLevel;
  };
  /**
   * @public
   * @method setErrorCorrectionLevel
   * @param {ErrorCorrectionLevel} errorCorrectionLevel
   */
  Encoder.prototype.setErrorCorrectionLevel = function (errorCorrectionLevel) {
    switch (errorCorrectionLevel) {
      case ErrorCorrectionLevel.ErrorCorrectionLevel.L:
      case ErrorCorrectionLevel.ErrorCorrectionLevel.M:
      case ErrorCorrectionLevel.ErrorCorrectionLevel.Q:
      case ErrorCorrectionLevel.ErrorCorrectionLevel.H:
        this.errorCorrectionLevel = errorCorrectionLevel;
    }
    return this;
  };
  /**
   * @public
   * @method getEncodingHint
   * @returns {boolean}
   */
  Encoder.prototype.getEncodingHint = function () {
    return this.encodingHint;
  };
  /**
   * @public
   * @method setEncodingHint
   * @param {boolean} encodingHint
   * @returns {Encoder}
   */
  Encoder.prototype.setEncodingHint = function (encodingHint) {
    this.encodingHint = encodingHint;
    return this;
  };
  /**
   * @public
   * @method write
   * @param {QRData} data
   * @returns {Encoder}
   */
  Encoder.prototype.write = function (data) {
    var chunks = this.chunks;
    if (data instanceof QRData.QRData) {
      chunks.push(data);
    } else {
      var type = toString.call(data);
      if (type === '[object String]') {
        chunks.push(new QRByte.QRByte(data));
      } else {
        throw new Error('illegal data: '.concat(data));
      }
    }
    return this;
  };
  /**
   * @public
   * @method isDark
   * @param {number} row
   * @param {number} col
   * @returns {boolean}
   */
  Encoder.prototype.isDark = function (row, col) {
    return this.matrix[row][col] === true;
  };
  Encoder.prototype.setupFinderPattern = function (row, col) {
    var matrix = this.matrix;
    var matrixSize = this.matrixSize;
    for (var r = -1; r <= 7; r++) {
      for (var c = -1; c <= 7; c++) {
        if (row + r <= -1 || matrixSize <= row + r || col + c <= -1 || matrixSize <= col + c) {
          continue;
        }
        if (
          (0 <= r && r <= 6 && (c === 0 || c === 6)) ||
          (0 <= c && c <= 6 && (r === 0 || r === 6)) ||
          (2 <= r && r <= 4 && 2 <= c && c <= 4)
        ) {
          matrix[row + r][col + c] = true;
        } else {
          matrix[row + r][col + c] = false;
        }
      }
    }
  };
  Encoder.prototype.setupAlignmentPattern = function () {
    var matrix = this.matrix;
    var pos = QRUtil.getAlignmentPattern(this.version);
    var length = pos.length;
    for (var i = 0; i < length; i++) {
      for (var j = 0; j < length; j++) {
        var row = pos[i];
        var col = pos[j];
        if (matrix[row][col] !== null) {
          continue;
        }
        for (var r = -2; r <= 2; r++) {
          for (var c = -2; c <= 2; c++) {
            if (r === -2 || r === 2 || c === -2 || c === 2 || (r === 0 && c === 0)) {
              matrix[row + r][col + c] = true;
            } else {
              matrix[row + r][col + c] = false;
            }
          }
        }
      }
    }
  };
  Encoder.prototype.setupTimingPattern = function () {
    var matrix = this.matrix;
    var count = this.matrixSize - 8;
    for (var i = 8; i < count; i++) {
      var bit = i % 2 === 0;
      // vertical
      if (matrix[i][6] === null) {
        matrix[i][6] = bit;
      }
      // horizontal
      if (matrix[6][i] === null) {
        matrix[6][i] = bit;
      }
    }
  };
  Encoder.prototype.setupFormatInfo = function (maskPattern) {
    var matrix = this.matrix;
    var data = (this.errorCorrectionLevel << 3) | maskPattern;
    var bits = QRUtil.getBCHVersionInfo(data);
    var matrixSize = this.matrixSize;
    for (var i = 0; i < 15; i++) {
      var bit = ((bits >> i) & 1) === 1;
      // Vertical
      if (i < 6) {
        matrix[i][8] = bit;
      } else if (i < 8) {
        matrix[i + 1][8] = bit;
      } else {
        matrix[matrixSize - 15 + i][8] = bit;
      }
      // Horizontal
      if (i < 8) {
        matrix[8][matrixSize - i - 1] = bit;
      } else if (i < 9) {
        matrix[8][15 - i - 1 + 1] = bit;
      } else {
        matrix[8][15 - i - 1] = bit;
      }
    }
    // Fixed point
    matrix[matrixSize - 8][8] = true;
  };
  Encoder.prototype.setupVersionInfo = function () {
    if (this.version >= 7) {
      var matrix = this.matrix;
      var matrixSize = this.matrixSize;
      var bits = QRUtil.getBCHVersion(this.version);
      for (var i = 0; i < 18; i++) {
        var bit = ((bits >> i) & 1) === 1;
        matrix[(i / 3) >> 0][(i % 3) + matrixSize - 8 - 3] = bit;
        matrix[(i % 3) + matrixSize - 8 - 3][(i / 3) >> 0] = bit;
      }
    }
  };
  Encoder.prototype.setupCodewords = function (data, maskPattern) {
    var matrix = this.matrix;
    var matrixSize = this.matrixSize;
    var bitLength = data.getLengthInBits();
    var maskFunc = MaskPattern.getMaskFunc(maskPattern);
    // Bit index into the data
    var bitIndex = 0;
    // Do the funny zigzag scan
    for (var right = matrixSize - 1; right >= 1; right -= 2) {
      // Index of right column in each column pair
      if (right === 6) {
        right = 5;
      }
      for (var vert = 0; vert < matrixSize; vert++) {
        // Vertical counter
        for (var j = 0; j < 2; j++) {
          // Actual x coordinate
          var x = right - j;
          var upward = ((right + 1) & 2) === 0;
          // Actual y coordinate
          var y = upward ? matrixSize - 1 - vert : vert;
          if (matrix[y][x] !== null) {
            continue;
          }
          var bit = false;
          if (bitIndex < bitLength) {
            bit = data.getBit(bitIndex++);
          }
          var invert = maskFunc(x, y);
          if (invert) {
            bit = !bit;
          }
          matrix[y][x] = bit;
        }
      }
    }
  };
  Encoder.prototype.buildMatrix = function (data, maskPattern) {
    // Initialize matrix
    var matrix = [];
    var matrixSize = this.matrixSize;
    for (var row = 0; row < matrixSize; row++) {
      matrix[row] = [];
      for (var col = 0; col < matrixSize; col++) {
        matrix[row][col] = null;
      }
    }
    this.matrix = matrix;
    // Setup finder pattern
    this.setupFinderPattern(0, 0);
    this.setupFinderPattern(matrixSize - 7, 0);
    this.setupFinderPattern(0, matrixSize - 7);
    // Setup alignment pattern
    this.setupAlignmentPattern();
    // Setup timing pattern
    this.setupTimingPattern();
    // Setup format info
    this.setupFormatInfo(maskPattern);
    // Setup version info
    this.setupVersionInfo();
    // Setup codewords
    this.setupCodewords(data, maskPattern);
  };
  /**
   * @public
   * @method make
   * @returns {Encoder}
   */
  Encoder.prototype.make = function () {
    var _a, _b;
    var buffer;
    var rsBlocks;
    var maxDataCount;
    var _c = this,
      chunks = _c.chunks,
      errorCorrectionLevel = _c.errorCorrectionLevel;
    if (this.auto) {
      var version = 1;
      for (; version <= 40; version++) {
        (_a = prepareData(version, errorCorrectionLevel, this.encodingHint, chunks)),
          (buffer = _a[0]),
          (rsBlocks = _a[1]),
          (maxDataCount = _a[2]);
        if (buffer.getLengthInBits() <= maxDataCount) break;
      }
      var dataLengthInBits = buffer.getLengthInBits();
      if (dataLengthInBits > maxDataCount) {
        throw new Error('data overflow: '.concat(dataLengthInBits, ' > ').concat(maxDataCount));
      }
      this.version = version;
    } else {
      (_b = prepareData(this.version, errorCorrectionLevel, this.encodingHint, chunks)),
        (buffer = _b[0]),
        (rsBlocks = _b[1]),
        (maxDataCount = _b[2]);
    }
    // Calc module count
    this.matrixSize = this.version * 4 + 17;
    var matrices = [];
    var data = createData(buffer, rsBlocks, maxDataCount);
    var bestMaskPattern = -1;
    var minPenalty = Number.MAX_VALUE;
    // Choose best mask pattern
    for (var maskPattern = 0; maskPattern < 8; maskPattern++) {
      this.buildMatrix(data, maskPattern);
      matrices.push(this.matrix);
      var penalty = QRUtil.calculateMaskPenalty(this);
      if (penalty < minPenalty) {
        minPenalty = penalty;
        bestMaskPattern = maskPattern;
      }
    }
    this.matrix = matrices[bestMaskPattern];
    return this;
  };
  /**
   * @public
   * @method toDataURL
   * @param {number} moduleSize
   * @param {number} margin
   * @returns {string}
   */
  Encoder.prototype.toDataURL = function (moduleSize, margin) {
    if (moduleSize === void 0) {
      moduleSize = 2;
    }
    if (margin === void 0) {
      margin = moduleSize * 4;
    }
    moduleSize = Math.max(1, moduleSize >> 0);
    margin = Math.max(0, margin >> 0);
    var matrixSize = this.matrixSize;
    var size = moduleSize * matrixSize + margin * 2;
    var min = margin;
    var max = size - margin;
    var gif = new GIFImage.GIFImage(size, size);
    for (var y = 0; y < size; y++) {
      for (var x = 0; x < size; x++) {
        if (min <= x && x < max && min <= y && y < max) {
          var row = ((y - min) / moduleSize) >> 0;
          var col = ((x - min) / moduleSize) >> 0;
          gif.setPixel(x, y, this.isDark(row, col) ? 0 : 1);
        } else {
          gif.setPixel(x, y, 1);
        }
      }
    }
    return gif.toDataURL();
  };
  /**
   * @public
   * @method clear
   */
  Encoder.prototype.clear = function () {
    this.chunks = [];
  };
  return Encoder;
})();

exports.Encoder = Encoder;

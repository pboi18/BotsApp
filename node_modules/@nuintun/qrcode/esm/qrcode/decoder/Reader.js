/**
 * @module QRCode
 * @package @nuintun/qrcode
 * @license MIT
 * @version 3.3.0
 * @author nuintun <nuintun@qq.com>
 * @description A pure JavaScript QRCode encode and decode library.
 * @see https://github.com/nuintun/qrcode#readme
 */

import { __assign } from 'tslib';
import { locate } from './locator.js';
import { extract } from './extractor.js';
import { decode } from './decoder/index.js';
import { binarize } from './binarizer.js';

/**
 * @module QRCode
 * @author nuintun
 * @author Cosmo Wolfe
 * @license https://raw.githubusercontent.com/cozmo/jsQR/master/LICENSE
 */
function scan(matrix) {
  var locations = locate(matrix);
  if (locations === null) {
    return null;
  }
  for (var _i = 0, locations_1 = locations; _i < locations_1.length; _i++) {
    var location_1 = locations_1[_i];
    var extracted = extract(matrix, location_1);
    var decoded = decode(extracted.matrix);
    if (decoded !== null) {
      var dimension = location_1.dimension;
      return __assign(__assign({}, decoded), {
        location: {
          topLeft: extracted.mappingFunction(0, 0),
          topRight: extracted.mappingFunction(dimension, 0),
          bottomLeft: extracted.mappingFunction(0, dimension),
          bottomRight: extracted.mappingFunction(dimension, dimension),
          topLeftFinder: location_1.topLeft,
          topRightFinder: location_1.topRight,
          bottomLeftFinder: location_1.bottomLeft,
          bottomRightAlignment: decoded.version > 1 ? location_1.alignmentPattern : null
        }
      });
    }
  }
  return null;
}
function disposeImageEvents(image) {
  image.onload = null;
  image.onerror = null;
}
var Decoder = /*#__PURE__*/ (function () {
  function Decoder(options) {
    if (options === void 0) {
      options = {};
    }
    this.options = options;
  }
  /**
   * @public
   * @method setOptions
   * @param {object} options
   */
  Decoder.prototype.setOptions = function (options) {
    this.options = __assign(__assign({}, this.options), options);
    return this;
  };
  /**
   * @public
   * @method decode
   * @param {Uint8ClampedArray} data
   * @param {number} width
   * @param {number} height
   * @returns {DecoderResult}
   */
  Decoder.prototype.decode = function (data, width, height) {
    var options = this.options;
    var canOverwriteImage = options.canOverwriteImage,
      greyScaleWeights = options.greyScaleWeights,
      _a = options.inversionAttempts,
      inversionAttempts = _a === void 0 ? 'attemptBoth' : _a;
    var tryInvertedFirst = inversionAttempts === 'onlyInvert' || inversionAttempts === 'invertFirst';
    var invert = tryInvertedFirst || inversionAttempts === 'attemptBoth';
    var _b = binarize(data, width, height, invert, greyScaleWeights, canOverwriteImage),
      binarized = _b.binarized,
      inverted = _b.inverted;
    var result = scan(tryInvertedFirst ? inverted : binarized);
    if (result !== null && (options.inversionAttempts === 'attemptBoth' || options.inversionAttempts === 'invertFirst')) {
      result = scan(tryInvertedFirst ? binarized : inverted);
    }
    return result;
  };
  /**
   * @public
   * @method scan
   * @param {string} src
   * @returns {Promise}
   */
  Decoder.prototype.scan = function (src) {
    var _this = this;
    return new Promise(function (resolve, reject) {
      var image = new Image();
      // Image cross origin
      image.crossOrigin = 'anonymous';
      image.onload = function () {
        disposeImageEvents(image);
        var width = image.width;
        var height = image.height;
        var canvas = document.createElement('canvas');
        var context = canvas.getContext('2d');
        if (context === null) {
          return reject(new Error("browser does not support canvas.getContext('2d')"));
        }
        canvas.width = width;
        canvas.height = height;
        context.drawImage(image, 0, 0);
        var data = context.getImageData(0, 0, width, height).data;
        var result = _this.decode(data, width, height);
        if (result !== null) {
          return resolve(result);
        }
        return reject(new Error('failed to decode image'));
      };
      image.onerror = function () {
        disposeImageEvents(image);
        reject(new Error('failed to load image: '.concat(src)));
      };
      image.src = src;
    });
  };
  return Decoder;
})();

export { Decoder };

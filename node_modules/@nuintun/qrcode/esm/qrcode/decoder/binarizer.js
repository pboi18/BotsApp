/**
 * @module QRCode
 * @package @nuintun/qrcode
 * @license MIT
 * @version 3.3.0
 * @author nuintun <nuintun@qq.com>
 * @description A pure JavaScript QRCode encode and decode library.
 * @see https://github.com/nuintun/qrcode#readme
 */

import { BitMatrix } from './BitMatrix.js';

/**
 * @module binarizer
 * @author nuintun
 * @author Cosmo Wolfe
 * @license https://raw.githubusercontent.com/cozmo/jsQR/master/LICENSE
 */
var REGION_SIZE = 8;
var MIN_DYNAMIC_RANGE = 24;
function numBetween(value, min, max) {
  return value < min ? min : value > max ? max : value;
}
// Like BitMatrix but accepts arbitry Uint8 values
var Matrix = /*#__PURE__*/ (function () {
  function Matrix(width, height, buffer) {
    this.width = width;
    var bufferSize = width * height;
    if (buffer && buffer.length !== bufferSize) {
      throw new Error('wrong buffer size');
    }
    this.data = buffer || new Uint8ClampedArray(bufferSize);
  }
  Matrix.prototype.get = function (x, y) {
    return this.data[y * this.width + x];
  };
  Matrix.prototype.set = function (x, y, value) {
    this.data[y * this.width + x] = value;
  };
  return Matrix;
})();
function binarize(data, width, height, returnInverted, greyscaleWeights, canOverwriteImage) {
  if (greyscaleWeights === void 0) {
    greyscaleWeights = {
      red: 0.2126,
      green: 0.7152,
      blue: 0.0722,
      useIntegerApproximation: false
    };
  }
  if (canOverwriteImage === void 0) {
    canOverwriteImage = true;
  }
  var pixelCount = width * height;
  if (data.length !== pixelCount * 4) {
    throw new Error('malformed data passed to binarizer');
  }
  // Assign the greyscale and binary image within the rgba buffer as the rgba image will not be needed after conversion
  var bufferOffset = 0;
  // Convert image to greyscale
  var greyscaleBuffer;
  if (canOverwriteImage) {
    greyscaleBuffer = new Uint8ClampedArray(data.buffer, bufferOffset, pixelCount);
    bufferOffset += pixelCount;
  }
  var greyscalePixels = new Matrix(width, height, greyscaleBuffer);
  for (var y = 0; y < height; y++) {
    for (var x = 0; x < width; x++) {
      var position = (y * width + x) * 4;
      var r = data[position];
      var g = data[position + 1];
      var b = data[position + 2];
      var value = greyscaleWeights.red * r + greyscaleWeights.green * g + greyscaleWeights.blue * b;
      greyscalePixels.set(x, y, greyscaleWeights.useIntegerApproximation ? (value + 128) >> 8 : value);
    }
  }
  var horizontalRegionCount = Math.ceil(width / REGION_SIZE);
  var verticalRegionCount = Math.ceil(height / REGION_SIZE);
  var blackPointsCount = horizontalRegionCount * verticalRegionCount;
  var blackPointsBuffer;
  if (canOverwriteImage) {
    blackPointsBuffer = new Uint8ClampedArray(data.buffer, bufferOffset, blackPointsCount);
    bufferOffset += blackPointsCount;
  }
  var blackPoints = new Matrix(horizontalRegionCount, verticalRegionCount, blackPointsBuffer);
  for (var verticalRegion = 0; verticalRegion < verticalRegionCount; verticalRegion++) {
    for (var hortizontalRegion = 0; hortizontalRegion < horizontalRegionCount; hortizontalRegion++) {
      var sum = 0;
      var min = Infinity;
      var max = 0;
      for (var y = 0; y < REGION_SIZE; y++) {
        for (var x = 0; x < REGION_SIZE; x++) {
          var pixelLumosity = greyscalePixels.get(hortizontalRegion * REGION_SIZE + x, verticalRegion * REGION_SIZE + y);
          sum += pixelLumosity;
          min = Math.min(min, pixelLumosity);
          max = Math.max(max, pixelLumosity);
        }
      }
      var average = sum / Math.pow(REGION_SIZE, 2);
      if (max - min <= MIN_DYNAMIC_RANGE) {
        // If variation within the block is low, assume this is a block with only light or only
        // dark pixels. In that case we do not want to use the average, as it would divide this
        // low contrast area into black and white pixels, essentially creating data out of noise.
        //
        // Default the blackpoint for these blocks to be half the min - effectively white them out
        average = min / 2;
        if (verticalRegion > 0 && hortizontalRegion > 0) {
          // Correct the "white background" assumption for blocks that have neighbors by comparing
          // the pixels in this block to the previously calculated black points. This is based on
          // the fact that dark barcode symbology is always surrounded by some amount of light
          // background for which reasonable black point estimates were made. The bp estimated at
          // the boundaries is used for the interior.
          // The (min < bp) is arbitrary but works better than other heuristics that were tried.
          var averageNeighborBlackPoint =
            (blackPoints.get(hortizontalRegion, verticalRegion - 1) +
              2 * blackPoints.get(hortizontalRegion - 1, verticalRegion) +
              blackPoints.get(hortizontalRegion - 1, verticalRegion - 1)) /
            4;
          if (min < averageNeighborBlackPoint) {
            average = averageNeighborBlackPoint;
          }
        }
      }
      blackPoints.set(hortizontalRegion, verticalRegion, average);
    }
  }
  var binarized;
  if (canOverwriteImage) {
    var binarizedBuffer = new Uint8ClampedArray(data.buffer, bufferOffset, pixelCount);
    bufferOffset += pixelCount;
    binarized = new BitMatrix(binarizedBuffer, width);
  } else {
    binarized = BitMatrix.createEmpty(width, height);
  }
  var inverted;
  if (returnInverted) {
    if (canOverwriteImage) {
      var invertedBuffer = new Uint8ClampedArray(data.buffer, bufferOffset, pixelCount);
      inverted = new BitMatrix(invertedBuffer, width);
    } else {
      inverted = BitMatrix.createEmpty(width, height);
    }
  }
  for (var verticalRegion = 0; verticalRegion < verticalRegionCount; verticalRegion++) {
    for (var hortizontalRegion = 0; hortizontalRegion < horizontalRegionCount; hortizontalRegion++) {
      var left = numBetween(hortizontalRegion, 2, horizontalRegionCount - 3);
      var top_1 = numBetween(verticalRegion, 2, verticalRegionCount - 3);
      var sum = 0;
      for (var xRegion = -2; xRegion <= 2; xRegion++) {
        for (var yRegion = -2; yRegion <= 2; yRegion++) {
          sum += blackPoints.get(left + xRegion, top_1 + yRegion);
        }
      }
      var threshold = sum / 25;
      for (var xRegion = 0; xRegion < REGION_SIZE; xRegion++) {
        for (var yRegion = 0; yRegion < REGION_SIZE; yRegion++) {
          var x = hortizontalRegion * REGION_SIZE + xRegion;
          var y = verticalRegion * REGION_SIZE + yRegion;
          var lum = greyscalePixels.get(x, y);
          binarized.set(x, y, lum <= threshold);
          if (returnInverted) {
            inverted.set(x, y, !(lum <= threshold));
          }
        }
      }
    }
  }
  if (returnInverted) {
    return { binarized: binarized, inverted: inverted };
  }
  return { binarized: binarized };
}

export { binarize };

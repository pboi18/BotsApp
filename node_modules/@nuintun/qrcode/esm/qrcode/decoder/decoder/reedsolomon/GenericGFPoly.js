/**
 * @module QRCode
 * @package @nuintun/qrcode
 * @license MIT
 * @version 3.3.0
 * @author nuintun <nuintun@qq.com>
 * @description A pure JavaScript QRCode encode and decode library.
 * @see https://github.com/nuintun/qrcode#readme
 */

import { addOrSubtractGF } from './GenericGF.js';

/**
 * @module GenericGFPoly
 * @author nuintun
 * @author Cosmo Wolfe
 * @license https://raw.githubusercontent.com/cozmo/jsQR/master/LICENSE
 */
var GenericGFPoly = /*#__PURE__*/ (function () {
  function GenericGFPoly(field, coefficients) {
    if (coefficients.length === 0) {
      throw new Error('no coefficients');
    }
    this.field = field;
    var coefficientsLength = coefficients.length;
    if (coefficientsLength > 1 && coefficients[0] === 0) {
      // Leading term must be non-zero for anything except the constant polynomial "0"
      var firstNonZero = 1;
      while (firstNonZero < coefficientsLength && coefficients[firstNonZero] === 0) {
        firstNonZero++;
      }
      if (firstNonZero === coefficientsLength) {
        this.coefficients = field.zero.coefficients;
      } else {
        this.coefficients = new Uint8ClampedArray(coefficientsLength - firstNonZero);
        for (var i = 0; i < this.coefficients.length; i++) {
          this.coefficients[i] = coefficients[firstNonZero + i];
        }
      }
    } else {
      this.coefficients = coefficients;
    }
  }
  GenericGFPoly.prototype.degree = function () {
    return this.coefficients.length - 1;
  };
  GenericGFPoly.prototype.isZero = function () {
    return this.coefficients[0] === 0;
  };
  GenericGFPoly.prototype.getCoefficient = function (degree) {
    return this.coefficients[this.coefficients.length - 1 - degree];
  };
  GenericGFPoly.prototype.addOrSubtract = function (other) {
    var _a;
    if (this.isZero()) {
      return other;
    }
    if (other.isZero()) {
      return this;
    }
    var smallerCoefficients = this.coefficients;
    var largerCoefficients = other.coefficients;
    if (smallerCoefficients.length > largerCoefficients.length) {
      (_a = [largerCoefficients, smallerCoefficients]), (smallerCoefficients = _a[0]), (largerCoefficients = _a[1]);
    }
    var sumDiff = new Uint8ClampedArray(largerCoefficients.length);
    var lengthDiff = largerCoefficients.length - smallerCoefficients.length;
    for (var i = 0; i < lengthDiff; i++) {
      sumDiff[i] = largerCoefficients[i];
    }
    for (var i = lengthDiff; i < largerCoefficients.length; i++) {
      sumDiff[i] = addOrSubtractGF(smallerCoefficients[i - lengthDiff], largerCoefficients[i]);
    }
    return new GenericGFPoly(this.field, sumDiff);
  };
  GenericGFPoly.prototype.multiply = function (scalar) {
    if (scalar === 0) {
      return this.field.zero;
    }
    if (scalar === 1) {
      return this;
    }
    var size = this.coefficients.length;
    var product = new Uint8ClampedArray(size);
    for (var i = 0; i < size; i++) {
      product[i] = this.field.multiply(this.coefficients[i], scalar);
    }
    return new GenericGFPoly(this.field, product);
  };
  GenericGFPoly.prototype.multiplyPoly = function (other) {
    if (this.isZero() || other.isZero()) {
      return this.field.zero;
    }
    var aCoefficients = this.coefficients;
    var aLength = aCoefficients.length;
    var bCoefficients = other.coefficients;
    var bLength = bCoefficients.length;
    var product = new Uint8ClampedArray(aLength + bLength - 1);
    for (var i = 0; i < aLength; i++) {
      var aCoeff = aCoefficients[i];
      for (var j = 0; j < bLength; j++) {
        product[i + j] = addOrSubtractGF(product[i + j], this.field.multiply(aCoeff, bCoefficients[j]));
      }
    }
    return new GenericGFPoly(this.field, product);
  };
  GenericGFPoly.prototype.multiplyByMonomial = function (degree, coefficient) {
    if (degree < 0) {
      throw new Error('invalid degree less than 0');
    }
    if (coefficient === 0) {
      return this.field.zero;
    }
    var size = this.coefficients.length;
    var product = new Uint8ClampedArray(size + degree);
    for (var i = 0; i < size; i++) {
      product[i] = this.field.multiply(this.coefficients[i], coefficient);
    }
    return new GenericGFPoly(this.field, product);
  };
  GenericGFPoly.prototype.evaluateAt = function (a) {
    var result = 0;
    if (a === 0) {
      // Just return the x^0 coefficient
      return this.getCoefficient(0);
    }
    var size = this.coefficients.length;
    if (a === 1) {
      // Just the sum of the coefficients
      this.coefficients.forEach(function (coefficient) {
        result = addOrSubtractGF(result, coefficient);
      });
      return result;
    }
    result = this.coefficients[0];
    for (var i = 1; i < size; i++) {
      result = addOrSubtractGF(this.field.multiply(a, result), this.coefficients[i]);
    }
    return result;
  };
  return GenericGFPoly;
})();

export { GenericGFPoly };
